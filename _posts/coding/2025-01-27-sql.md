---
layout: post
title: javaScript
date: 2025-01-27 14:00 +0900
description: 
image: ../assets/img/front.jpg
category: [JS,]
tags: JS
published: true
sitemap: true
---

# SQL

## 스토어드 프로시저

커서 == 포인터

````sql
DROP PROCEDURE 함수명;
// 스토어드 프로시저 삭제
````

* 입력 매개변수
````sql
USE market_db;
DROP PROCEDURE IF EXISTS user_proc1;
DELIMITER $$
CREATE PROCEDURE user_proc1(IN userName VARCHAR(10))
BEGIN
	SELECT * FROM member WHERE mem_name = userName;
END $$
DELIMITER ;

CALL user_proc1('에이핑크');
````

* 출력 매개변수

````sql
DROP PROCEDURE IF EXISTS user_proc3;
DELIMITER $$
CREATE PROCEDURE user_proc3(
	IN txtValue CHAR(10),
    OUT outValue INT )
BEGIN
	INSERT INTO noTable VALUES(NULL, txtValue);
    SELECT MAX(id) INTO outValue FROM noTable;
END $$
DELIMITER ;

CALL user_proc3 ('테스트1', @myValue);
SELECT CONCAT('입력된 ID 값 ==>' ,@myValue);
````

* 연, 월, 일 
````sql
SELECT YEAR(CURDATE()), MONTH(CURDATE()), DAY(CURDATE());
````

* 요일
````sql
SELECT DAYNAME(CURDATE()); // 영어 요일 출력
SELECT WEEKDAY(CURDATE()); // 요일을 숫자로 반환, 월요일=0
````

* 시, 분, 초
````sql
HOUR(NOW())
MINUTE(NOW())
SECOND(NOW())
````

````sql
SET @sqlQuery = CONCAT('SELECT * FROM ', 'employees');  -- 동적으로 테이블명을 결합하여 쿼리문 생성
PREPARE myQuery FROM @sqlQuery;  -- 쿼리 준비, 이름 부여
EXECUTE myQuery;  -- 쿼리 실행
DEALLOCATE PREPARE myQuery;  -- 쿼리 리소스 해제
````
## 스토어드 함수

````sql
DELIMITER $$
CREATE FUNCTION 스토어드_함수_이름(매개변수) // 입력 매개변수만 받음, IN 안붙임
    RETURNS 반환형식
BEGIN
    이 부분에 프로그래밍 코딩
    RETURN 반환값;
END $$
DELIMITER ;
SELECT 스토어드_함수_이름(); // CALL이 아닌 SELECT로 호출
````
````sql
SET GLOBAL log_bin_trust_function_creators = 1;
// 스토어드 함수 생성 권한 허용(mySQL 처음에만 설정)
````

````sql
DROP FUNCTION 함수_이름;
````

## 커서
커서 선언하기 -> 반복 조건 선언하기 -> 커서 열기 -> (데이터 가져오기 -> 데이터 처리하기)반복 -> 커서 닫기

````sql
DROP PROCEDURE IF EXISTS cursor_proc;
DELIMITER $$
CREATE PROCEDURE cursor_proc()
BEGIN
	DECLARE memNumber INT;
    DECLARE cnt INT DEFAULT 0;
    DECLARE totNumber INT DEFAULT 0;
    DECLARE endOfRow BOOLEAN DEFAULT FALSE; // 변수 선언
    
    DECLARE memberCursor CURSOR FOR 
		SELECT mem_number FROM member; // 커서 선언
	
    DECLARE CONTINUE HANDLER
		FOR NOT FOUND SET endOfRow = TRUE; // 반복 조건 선언
	
    OPEN memberCursor; // 커서 열기
    
    cursor_loop: LOOP 
		FETCH memberCursor INTO memNumber; fetch - 한 행 읽어오기
	
		IF endOfRow THEN
			LEAVE cursor_loop;
		END IF;
        
        SET cnt = cnt + 1;
        SET totNumber = totNumber + memNumber;
	END LOOP cursor_loop; // 행 반복
    
    SELECT (totNumber/cnt) AS '회원의 평균 인원 수';
    
    CLOSE memberCursor; // 커서 닫기
END $$
DELIMITER ;

CALL cursor_proc();
````

## 트리거
- INSERT, UPDATE, DELETE 문이 작동할 때 자동으로 실행되는 프로그래밍 기능
````sql
DROP TRIGGER IF EXISTS myTrigger;
DELIMITER $$
CREATE TRIGGER myTrigger
	AFTER DELETE
	ON trigger_table
    FOR EACH ROW
BEGIN
	SET @msg = '가수 그룹이 삭제됨';
END $$
DELIMITER ;
````

````sql
// 백업 만들기
DROP TRIGGER IF EXISTS singer_updateTrg;
DELIMITER $$
CREATE TRIGGER singer_updateTrg
	AFTER UPDATE
    ON singer
    FOR EACH ROW
BEGIN
	INSERT INTO backup_singer VALUES (OLD.mem_id, OLD.mem_name, 
		OLD.mem_number, OLD.addr, '수정', CURDATE(), CURRENT_USER());
END $$
DELIMITER ;
````

NEW, OLD - 트리거가 사용하는 임시 테이블
