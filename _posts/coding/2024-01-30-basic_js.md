---
layout: post
title: javaScript
date: 2024-01-30 14:00 +0900
description: 
image: ../assets/img/front.jpg
category: [JS,]
tags: JS
published: true
sitemap: true
---

# 자바스크립트 기초   

## 제너레이터

- 이터러블을 생성하는 함수, 비동기 처리에 유용, 이터레이터를 쉽게 표기하기 위한 문법적 설탕
- https://poiemaweb.com/es6-generator

````javascript
function* counter() { 
    console.log("first");
    yield 1; // 첫번째 next
    console.log("second");
    yield 2; // 두번째 next
    console.log("third"); // 세번째 next
}

const generatorObj = counter();

console.log(generatorObj.next());
console.log(generatorObj.next());
console.log(generatorObj.next());
````
- 제너레이터 함수는 일반 함수와 같이 함수의 코드 블록을 한 번에 실행하지 않고 함수 코드 블록의 실행을 일시 중지했다가 필요한 시점에 재시작할 수 있는 특수한 함수(yield를 기준으로)

    - 이터레이터의 next() - value와 done의 한 객체를 기준
    - 제너레이터의 next() - yield까지의 독립실행 기준

````javascript
function* counter() { 
    for (const v of [1, 2, 3]) yield v;
    // === yield* [1,2,3];
}

let generatorObj = counter();

console.log(Symbol.iterator in generatorObj);

for (const i of generatorObj) { 
    console.log(i);
}

generatorObj = counter();

console.log('next' in generatorObj);

console.log(generatorObj.next());
console.log(generatorObj.next());
console.log(generatorObj.next());
console.log(generatorObj.next());
````

## 제너레이터 정의

````javascript
// 제너레이터 함수 선언문
function* genDecFunc() { 
    yield 1;
}

let generatorObj = genDecFunc();

// 제너레이터 함수 표현식
const genExpFunc = function* () { 
    yield 1;
}

generatorObj = genExpFunc();

// 제너레이터 메소드
const obj = {
    * generatorObjMethod() { 
        yield 1;
    }
}

generatorObj = obj.generatorObjMethod();

// 제너레이터 클래스 메소드
class MyClass { 
    * generatorClsMethod() { 
        yield 1;
    }
}

const mc = new MyClass();
generatorObj = mc.generatorClsMethod();
````

- return this를 명료하게 알아보지 못하기 때문에 화살표 함수 사용 못함

https://velog.io/@ahsy92/JavaScript-Generator%EC%99%80-Yield

````javascript
function* call () {
	console.log('start')
  	let i = 0
    
    try{
    	while(true){
        	yield i++
        }
    } catch (e) {
    	console.log('error', e)
    }
}

const calling = call()
console.log(calling.next())
console.log(calling.next())
console.log(calling.next())
console.log(calling.return(10)) // return이 호출되고 나면, done은 true가 된다.
console.log(calling.next())

// 'start'
// {value: 0, done: false}
// {value: 1, done: false}
// {value: 2, done: false}
// {value: 10, done: true}
// {value: undefined, done: true}
````
